#pragma once
#include <cstdint> // std::ptrdiff_t
#include <iterator> // std::contiguous_iterator
#include "vassert.h"

#ifdef VASSERT_ENABLED
// Similarly to STL, iterators have a debug mode that allows for bounds checking
// and on iterator comparisons whether the two iterators point to the same container.
#define DEBUG_ITERATOR
#define DEBUG_ITERATOR_ONLY(...) __VA_ARGS__
#else
#define DEBUG_ITERATOR_ONLY(...)
#endif // VASSERT_ENABLED

template <typename T, typename Container>
class ArrayIterator {
	// Pointer-to element
	T* data = nullptr;
	// The debug mode has a minimal memory & speed overhead (one additional pointer).
	// When not in debug mode, an iterator is no larger & slower than a simple pointer.
#ifdef DEBUG_ITERATOR
	// Pointer to the container that created this iterator. Not a reference
	// (it will forbid moving iterators). Unfortunately, it cannot detect
	// whether the container pointer is dangling, f.e. to a moved container.
	Container* owner = nullptr;
	bool valid() const {
		return (data >= owner->begin().data && data < owner->end().data);
	}
#endif // DEBUG_ITERATOR

	// Only the pointed-to container can construct iterators (to itself)
	friend Container;
	ArrayIterator(T* data, [[maybe_unused]] Container* owner)
		: data{ data } DEBUG_ITERATOR_ONLY(, owner{ owner })
	{
		static_assert(std::contiguous_iterator<ArrayIterator>);
	}
public:
	// Default-constructor required for some std iterator concepts
	ArrayIterator() = default;
	// Iterator value types should be non-const even for const iterators
	using value_type = std::remove_const_t<T>;
	using pointer    = T*;
	using reference  = T&;
	using difference_type   = std::ptrdiff_t;
	using iterator_category = std::contiguous_iterator_tag;
	using iterator_concept  = std::contiguous_iterator_tag;
	reference operator*() const { return *operator->(); }
	pointer operator->() const {
		DEBUG_ITERATOR_ONLY(vassert(valid()));
		return data;
	}
	// All other methods, required by the std::contiguous_iterator concept
	ArrayIterator operator+(const difference_type n) const { return { data + n DEBUG_ITERATOR_ONLY(, owner) }; }
	ArrayIterator operator-(const difference_type n) const { return { data - n DEBUG_ITERATOR_ONLY(, owner) }; }
	ArrayIterator& operator+=(const difference_type n) { data += n; return *this; }
	ArrayIterator& operator-=(const difference_type n) { data -= n; return *this; }
	reference operator[](const difference_type n) const { return *(*this + n); }
	difference_type operator-(const ArrayIterator& other) const {
		DEBUG_ITERATOR_ONLY(vassert(owner == other.owner));
		return (data - other.data);
	}
	friend ArrayIterator operator+(const difference_type n, const ArrayIterator& it) { return (it + n); }
	ArrayIterator& operator++() { ++data; return *this; }
	ArrayIterator& operator--() { --data; return *this; }
	ArrayIterator operator++(int) { auto copy = *this; ++(*this); return copy; }
	ArrayIterator operator--(int) { auto copy = *this; --(*this); return copy; }
	// The remaining comparison operators will be generated by the compiler.
	bool operator==(const ArrayIterator& other) const {
		DEBUG_ITERATOR_ONLY(vassert(owner == other.owner));
		return (data == other.data);
	}
	auto operator<=>(const ArrayIterator &other) const {
		DEBUG_ITERATOR_ONLY(vassert(owner == other.owner));
		return (data <=> other.data);
	}
};
