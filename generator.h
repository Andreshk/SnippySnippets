#pragma once
#include <coroutine>
#include <utility> // std::exchange

// Synchronized generator for values of type T - to be returned from a coroutine.
// Adapted from Rainer Grimm, "Concurrency with Modern C++"
// To-do: make it iterable as a single-pass input_range
template<typename T>
class Generator {
public:
    struct promise_type;
    using Handle = std::coroutine_handle<promise_type>;
private:
    Handle handle;
public:
    explicit Generator(Handle handle) : handle{ handle } {}
    Generator(const Generator&) = delete; // Generally not a good idea to have multiple handles to the same coroutine
    Generator(Generator&& other) noexcept : handle{ std::exchange(other.handle, nullptr) } {}
    Generator& operator=(const Generator&) = delete;
    Generator& operator=(Generator&& other) noexcept {
        handle = std::exchange(other.handle, nullptr);
        return *this;
    }
    ~Generator() {
        if (handle) {
            handle.destroy();
        }
    }
    // Resume (!) the coroutine & wait for it to signal whether it can generate more values
    bool next() const {
        handle.resume();
        return !handle.done();
    }
    // Get the last value, generated by the coroutine
    const T& operator*() const {
        return *handle.promise().current;
    }

    struct promise_type {
    private:
        friend Generator;
        const T* current;
    public:
        promise_type() : current{ nullptr } {};
        promise_type(const promise_type&) = delete;
        promise_type(promise_type&&) = delete;
        promise_type &operator=(const promise_type&) = delete;
        promise_type &operator=(promise_type&&) = delete;
        ~promise_type() = default;

        std::suspend_always initial_suspend() { return {}; }
        std::suspend_always final_suspend() { return {}; }
        std::suspend_never return_void() { return {}; }

        Generator get_return_object() { return Generator{ Handle::from_promise(*this) }; }

        // Note: it is safe to store the address of the given value, even if it's a
        // temporary (!), since its lifetime "crosses the suspension point" anyway.
        std::suspend_always yield_value(const T& value) {
            current = &value;
            return {};
        }

        void unhandled_exception() {
            std::exit(1);
        }
    };
};
